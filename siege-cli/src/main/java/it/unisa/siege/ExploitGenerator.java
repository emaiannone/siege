package it.unisa.siege;

import org.apache.commons.lang3.tuple.Pair;
import org.evosuite.EvoSuite;
import org.evosuite.Properties;
import org.evosuite.coverage.vulnerability.VulnerabilityDescription;
import org.evosuite.ga.FitnessFunction;
import org.evosuite.ga.metaheuristics.GeneticAlgorithm;
import org.evosuite.ga.stoppingconditions.MaxTimeStoppingCondition;
import org.evosuite.ga.stoppingconditions.StoppingCondition;
import org.evosuite.result.TestGenerationResult;
import org.evosuite.testcase.TestCase;
import org.evosuite.testcase.TestChromosome;
import org.evosuite.utils.LoggingUtils;
import org.slf4j.Logger;

import java.util.*;
import java.util.stream.Collectors;

public class ExploitGenerator {
    private final EvoSuite evoSuite;
    private static final Logger logger = LoggingUtils.getEvoLogger();

    public static final String STATUS_UNREACHABLE = "UNREACHABLE";
    public static final String STATUS_SUCCESS = "SUCCESS";
    public static final String STATUS_FAILED = "FAILED";

    public ExploitGenerator(EvoSuite evoSuite) {
        this.evoSuite = evoSuite;
    }

    public List<Map<String, String>> generateExploits(List<Pair<String, VulnerabilityDescription>> vulnerabilityList, List<String> baseCommands) {
        List<Map<String, String>> results = new ArrayList<>();
        for (int i = 0; i < vulnerabilityList.size(); i++) {
            Pair<String, VulnerabilityDescription> vulnerability = vulnerabilityList.get(i);
            logger.info("\n({}/{}) Going to generate exploits for: {}", i + 1, vulnerabilityList.size(), vulnerability.getLeft());
            List<String> evoSuiteCommands = new ArrayList<>(baseCommands);
            evoSuiteCommands.add("-Djunit_suffix=" + "_" + vulnerability.getLeft().replace("-", "_") + "_SiegeTest");
            evoSuiteCommands.add("-DvulnClass=" + vulnerability.getRight().getVulnerableClass());
            evoSuiteCommands.add("-DvulnMethod=" + vulnerability.getRight().getVulnerableMethod());
            List<List<TestGenerationResult<TestChromosome>>> evoSuiteResults;
            try {
                evoSuiteResults = (List<List<TestGenerationResult<TestChromosome>>>)
                        evoSuite.parseCommandLine(evoSuiteCommands.toArray(new String[0]));
            } catch (Exception e) {
                // Print and go to next iteration
                logger.error("Error while generating exploits for " + vulnerability.getLeft() + ". Skipping.", e);
                continue;
            }
            logger.info("\n-> Results for {}", vulnerability.getLeft());
            if (evoSuiteResults.size() > 0) {
                for (List<TestGenerationResult<TestChromosome>> testResults : evoSuiteResults) {
                    for (TestGenerationResult<TestChromosome> clientClassResult : testResults) {
                        Map<String, String> result = new LinkedHashMap<>();
                        GeneticAlgorithm<TestChromosome> algorithm = clientClassResult.getGeneticAlgorithm();
                        String clientClass = clientClassResult.getClassUnderTest();
                        result.put("cve", vulnerability.getLeft());
                        result.put("clientClass", clientClass);
                        Map<String, TestCase> wroteTests = clientClassResult.getTestCases();
                        if (wroteTests.size() == 0) {
                            result.putAll(createUnreachableResult());
                            results.add(result);
                            logger.info("--> Could not be reached from class '{}'", clientClass);
                            continue;
                        }

                        // Since EvoSuite does not properly handle the getCurrentValue() method in MaxTimeStoppingCondition, I use an ad hoc method.
                        // For the same reason, isFinished() is unreliable: we have to use spentBudget <= SEARCH_BUDGET
                        long spentBudget = 0;
                        long totalBudget = Properties.SEARCH_BUDGET;
                        for (StoppingCondition<TestChromosome> stoppingCondition : algorithm.getStoppingConditions()) {
                            if (stoppingCondition instanceof MaxTimeStoppingCondition) {
                                MaxTimeStoppingCondition<TestChromosome> timeStoppingCondition = (MaxTimeStoppingCondition<TestChromosome>) stoppingCondition;
                                spentBudget = timeStoppingCondition.getSpentBudget();
                                break;
                            }
                        }
                        // Get the individuals covering any goal
                        TestChromosome bestIndividual = getBestIndividual(algorithm);
                        // Use ad hoc function because getFitness() offered by EvoSuite does not "fit" our needs
                        double bestFitness = getBestFitness(bestIndividual);
                        // Check if budget is not exhausted and at least one goal was covered
                        if (spentBudget < totalBudget && bestFitness == 0) {
                            result.put("status", STATUS_SUCCESS);
                        } else {
                            result.put("status", STATUS_FAILED);
                        }
                        long iterations = algorithm.getAge() + 1;

                        result.put("entryPaths", String.valueOf(algorithm.getFitnessFunctions().size()));
                        result.put("exploitedPaths", String.valueOf(wroteTests.size()));
                        result.put("totalBudget", String.valueOf(totalBudget));
                        result.put("spentBudget", String.valueOf(spentBudget));
                        result.put("populationSize", String.valueOf(Properties.POPULATION));
                        result.put("bestFitness", String.valueOf(bestFitness));
                        result.put("iterations", String.valueOf(iterations));
                        results.add(result);
                        logger.info("--> Reached via {}/{} paths from class '{}'", result.get("exploitedPaths"), result.get("entryPaths"), result.get("clientClass"));
                        logger.info("---> Using {}/{} seconds, within {} iterations.", result.get("spentBudget"), result.get("totalBudget"), result.get("iterations"));
                    }
                }
            } else { // TODO Probably this is now unneeded: to be removed. When this is removed, createUnreachableResult() can be inlined
                Map<String, String> result = new LinkedHashMap<>();
                result.put("cve", vulnerability.getLeft());
                result.put("status", STATUS_UNREACHABLE);
                results.add(result);
                logger.info("--> Could not be reached from any client class");
            }
        }
        return results;
    }

    private Map<String, String> createUnreachableResult() {
        Map<String, String> result = new LinkedHashMap<>();
        result.put("status", STATUS_UNREACHABLE);
        result.put("entryPaths", "0");
        result.put("exploitedPaths", "0");
        result.put("totalBudget", String.valueOf(Properties.SEARCH_BUDGET));
        result.put("spentBudget", "");
        result.put("populationSize", String.valueOf(Properties.POPULATION));
        result.put("bestFitness", "");
        result.put("iterations", "");
        return result;
    }

    private TestChromosome getBestIndividual(GeneticAlgorithm<TestChromosome> algorithm) {
        List<? extends FitnessFunction<TestChromosome>> fitnessFunctions = algorithm.getFitnessFunctions();
        List<TestChromosome> population = algorithm.getPopulation();
        List<TestChromosome> coveringIndividuals = population.stream()
                .filter(tc -> fitnessFunctions.stream().anyMatch(fit -> tc.getFitness(fit) == 0))
                .collect(Collectors.toList());
        if (coveringIndividuals.size() > 0) {
            // Prefer the shortest one
            return coveringIndividuals.stream().min(Comparator.comparingInt(tc -> tc.getTestCase().size())).orElse(null);
        } else {
            // When there are no covering individuals get the top minimal fitness (among all goals)
            double minFitness = Double.MAX_VALUE;
            TestChromosome bestIndividual = null;
            for (TestChromosome tc : population) {
                double bestFit = getBestFitness(tc);
                if (bestFit < minFitness) {
                    minFitness = bestFit;
                    bestIndividual = tc;
                }
            }
            return bestIndividual;
        }
    }

    private double getBestFitness(TestChromosome individual) {
        return Collections.min(individual.getFitnessValues().values());
    }

}
